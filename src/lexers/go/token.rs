// ---- DON'T EDIT THIS IS AUTO GENERATED CODE ---- //
#[derive(PartialEq)]
#[derive(Debug)]
pub enum Token {
	ILLEGAL,
	EOF,
	CH(char),
	ENDL(char),
	INT(Vec<char>),
	IDENT(Vec<char>),
	ENTITY(Vec<char>),
	STRING(Vec<char>),
	KEYWORD(Vec<char>),
	ARGS(Vec<char>),
	TRUE(Vec<char>),
	FALSE(Vec<char>),
	NIL(Vec<char>),
	BOOL(Vec<char>),
	CINT(Vec<char>),
	UINT(Vec<char>),
	BYTE(Vec<char>),
	CSTRING(Vec<char>),
	ERROR(Vec<char>),
	RUNE(Vec<char>),
	UINTPTR(Vec<char>),
	FLOAT(Vec<char>),
	PACKAGE(Vec<char>),
	FUNC(Vec<char>),
	FOR(Vec<char>),
	VAR(Vec<char>),
	IF(Vec<char>),
	ELSE(Vec<char>),
	MATCH(Vec<char>),
	CASE(Vec<char>),
	RETURN(Vec<char>),
	DEFAULT(Vec<char>),
	IMPORT(Vec<char>),
	TYPE(Vec<char>),
	INTERFACE(Vec<char>),
	CHAN(Vec<char>),
	STRUCT(Vec<char>),
	CONST(Vec<char>),
	RANGE(Vec<char>),
	BREAK(Vec<char>),
	MAP(Vec<char>),
	CONTINUE(Vec<char>),
	COMMENT(Vec<char>),
}

pub fn get_keyword_token(identifier: &Vec<char>) -> Result<Token, String> {
	let identifiers: String = identifier.into_iter().collect();
	match &identifiers[..] {
		"Args" => Ok(Token::ARGS(identifier.to_vec())),
		"true" => Ok(Token::TRUE(identifier.to_vec())),
		"false" => Ok(Token::FALSE(identifier.to_vec())),
		"nil" => Ok(Token::NIL(identifier.to_vec())),
		"bool" => Ok(Token::BOOL(identifier.to_vec())),
		"int" => Ok(Token::CINT(identifier.to_vec())),
		"uint" => Ok(Token::UINT(identifier.to_vec())),
		"byte" => Ok(Token::BYTE(identifier.to_vec())),
		"string" => Ok(Token::CSTRING(identifier.to_vec())),
		"error" => Ok(Token::ERROR(identifier.to_vec())),
		"rune" => Ok(Token::RUNE(identifier.to_vec())),
		"uintptr" => Ok(Token::UINTPTR(identifier.to_vec())),
		"float" => Ok(Token::FLOAT(identifier.to_vec())),
		"package" => Ok(Token::PACKAGE(identifier.to_vec())),
		"func" => Ok(Token::FUNC(identifier.to_vec())),
		"for" => Ok(Token::FOR(identifier.to_vec())),
		"var" => Ok(Token::VAR(identifier.to_vec())),
		"if" => Ok(Token::IF(identifier.to_vec())),
		"else" => Ok(Token::ELSE(identifier.to_vec())),
		"switch" => Ok(Token::MATCH(identifier.to_vec())),
		"case" => Ok(Token::CASE(identifier.to_vec())),
		"return" => Ok(Token::RETURN(identifier.to_vec())),
		"default" => Ok(Token::DEFAULT(identifier.to_vec())),
		"import" => Ok(Token::IMPORT(identifier.to_vec())),
		"type" => Ok(Token::TYPE(identifier.to_vec())),
		"interface" => Ok(Token::INTERFACE(identifier.to_vec())),
		"chan" => Ok(Token::CHAN(identifier.to_vec())),
		"struct" => Ok(Token::STRUCT(identifier.to_vec())),
		"const" => Ok(Token::CONST(identifier.to_vec())),
		"range" => Ok(Token::RANGE(identifier.to_vec())),
		"break" => Ok(Token::BREAK(identifier.to_vec())),
		"map" => Ok(Token::MAP(identifier.to_vec())),
		"continue" => Ok(Token::CONTINUE(identifier.to_vec())),
		_ => Err(String::from("Not a keyword"))
	}
}
