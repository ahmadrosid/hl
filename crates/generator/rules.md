# Rules
To parse the source code and render it with html is done by [LR Parser](https://en.wikipedia.org/wiki/LR_parser) algorithm. The lexers is auto generated by the rules located in `rules/` folder.

Here's the documentation of the rules available for our lexers.
```
- slash_comment
- slash_star_comment
- hashtag_comment
- double_dash_comment
- constant
- condition
- single_constant
- keyword
- single_keyword
- entity
- entity_tag
- var
- entity_prefix
- entity_suffix
```

### Comment
Programming language has several implementation of comment, to generate lexer for detecting the comment we have several register for that. The rendering for comment will be handled with this generated code.
```rust
match token {
    ...
    token::Token::COMMENT(value) => {
        let mut lines = String::new();
        for ch in value {
            if ch == '<' {
                lines.push_str("&lt;");
            } else if ch == '>' {
                lines.push_str("&gt;");
            } else {
                lines.push(ch);
            }
        }
        let split = lines.split("\n");
        let split_len = split.clone().collect::<Vec<&str>>().len();
        let mut index = 0;
        for val in split {
            html.push_str(&format!("<span class=\"hl-cmt\">{}</span>", val));
            index = index + 1;
            if index != split_len {
                line = line + 1;
                html.push_str("</td></tr>\n");
                html.push_str(&format!(
                    "<tr><td class=\"hl-num\" data-line=\"{}\"></td><td>",
                    line
                ));
            }
        }
    }
```

Now let's see how the lexer generated for each comment register.

#### 1. slash_comment
This register will parse one line when the string start with `//`, the lexer will stop when is reach the new line char `\n`.
```java
// This is comment.
This is not valid comment.
```

The lexer generated will be like this.
```rust
let read_slash_comment = |l: &mut Lexer| -> Vec<char> {
    let position = l.position;
    while l.position < l.input.len() {
        l.read_char();
        if l.input[l.position + 1] == '\n' {
            break;
        }
    }
    l.input[position..l.position + 1].to_vec()
};

...

let tok: token::Token;
match self.ch {
    ...
    '/' => {
        if self.input[self.position + 1] == '/' {
            tok = token::Token::COMMENT(read_slash_comment(self));
        } else {
            tok = token::Token::CH(self.ch);
        }
    }

```

#### 2. slash_star_comment
This register will parse the multi line string, the lexer will stop when is reach the end comment mark `*/`.
```java
/*
This is comment.
 */
This is not valid comment.
```

The generated code will be like this.

```rust
let read_slash_star_comment = |l: &mut Lexer| -> Vec<char> {
    let position = l.position;
    while l.position < l.input.len() {
        if l.position == l.input.len() {
            break;
        }
        if l.input[l.position + 1] == '*' {
            if l.input[l.position + 2] == '/' {
                l.read_char();
                l.read_char();
                break;
            }
        }
        l.read_char();
    }
    l.input[position..l.position + 1].to_vec()
};


let tok: token::Token;
match self.ch {
    ...
    '/' => {
        if self.input[self.position + 1] == '*' {
            tok = token::Token::COMMENT(read_slash_star_comment(self));
        }
        self.read_char();
        return tok;
    }
```

#### 3. hashtag_comment
This register will parse one line string when the starting char is `#`, the lexer will stop when is reach the new line `\n`.
```bash
# This is comment.
This is not valid comment.
```

For this register it will be more simple
```rust
let tok: token::Token;
if self.ch == '#' {
    let comment: Vec<char> = read_string(self, '\n');
    return token::Token::COMMENT(comment);
}
```

#### 4. double_dash_comment
This register will parse one line string, the lexer will stop when is reach the new line char `\n`.
```lua
-- This is comment.
This is not valid comment.
```

And this is the generated code for it.
```rust
if self.ch == '-' {
    let next_ch = self.input[self.position + 1];
    if self.position + 1 < self.input.len() && next_ch == '-' {
        let mut comment = vec!['-','-'];
        self.read_char();
        self.read_char();
        let last_position = self.position;
        while self.position < self.input.len() {
            if self.ch == '\n' {
                break;
            }
            self.read_char();
        }
        comment.append(&mut self.input[last_position..self.position].to_vec());
        return token::Token::COMMENT(comment);
    }
}
```
